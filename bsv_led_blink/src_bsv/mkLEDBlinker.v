//
// Generated by Bluespec Compiler, version 2025.01.1 (build 65e3a87)
//
// On Tue Apr  8 16:41:55 IST 2025
//
//
// Ports:
// Name                         I/O  size props
// leds                           O     8 reg
// RDY_leds                       O     1 const
// RDY_reset                      O     1 const
// CLK_clk                        I     1 clock
// RST_N_rst                      I     1 reset
// CLK                            I     1 unused
// RST_N                          I     1 unused
// EN_reset                       I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkLEDBlinker(CLK_clk,
		    RST_N_rst,
		    CLK,
		    RST_N,

		    leds,
		    RDY_leds,

		    EN_reset,
		    RDY_reset);
  input  CLK_clk;
  input  RST_N_rst;
  input  CLK;
  input  RST_N;

  // value method leds
  output [7 : 0] leds;
  output RDY_leds;

  // action method reset
  input  EN_reset;
  output RDY_reset;

  // signals for module outputs
  wire [7 : 0] leds;
  wire RDY_leds, RDY_reset;

  // register counter
  reg [31 : 0] counter;
  wire [31 : 0] counter$D_IN;
  wire counter$EN;

  // register ledValue
  reg [7 : 0] ledValue;
  wire [7 : 0] ledValue$D_IN;
  wire ledValue$EN;

  // register patternState
  reg patternState;
  wire patternState$D_IN, patternState$EN;

  // inputs to muxes for submodule ports
  wire [31 : 0] MUX_counter$write_1__VAL_2;
  wire [7 : 0] MUX_ledValue$write_1__VAL_2;

  // remaining internal signals
  wire [31 : 0] x__h170;

  // value method leds
  assign leds = ledValue ;
  assign RDY_leds = 1'd1 ;

  // action method reset
  assign RDY_reset = 1'd1 ;

  // inputs to muxes for submodule ports
  assign MUX_counter$write_1__VAL_2 =
	     (counter < 32'd24999999) ? x__h170 : 32'd0 ;
  assign MUX_ledValue$write_1__VAL_2 =
	     patternState ? 8'b01010101 : 8'b10101010 ;

  // register counter
  assign counter$D_IN = EN_reset ? 32'd0 : MUX_counter$write_1__VAL_2 ;
  assign counter$EN = 1'b1 ;

  // register ledValue
  assign ledValue$D_IN =
	     EN_reset ? 8'b10101010 : MUX_ledValue$write_1__VAL_2 ;
  assign ledValue$EN = counter == 32'd0 || EN_reset ;

  // register patternState
  assign patternState$D_IN = !EN_reset && !patternState ;
  assign patternState$EN = counter == 32'd0 || EN_reset ;

  // remaining internal signals
  assign x__h170 = counter + 32'd1 ;

  // handling of inlined registers

  always@(posedge CLK_clk)
  begin
    if (RST_N_rst == `BSV_RESET_VALUE)
      begin
        counter <= `BSV_ASSIGNMENT_DELAY 32'd0;
	ledValue <= `BSV_ASSIGNMENT_DELAY 8'b10101010;
	patternState <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (counter$EN) counter <= `BSV_ASSIGNMENT_DELAY counter$D_IN;
	if (ledValue$EN) ledValue <= `BSV_ASSIGNMENT_DELAY ledValue$D_IN;
	if (patternState$EN)
	  patternState <= `BSV_ASSIGNMENT_DELAY patternState$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    counter = 32'hAAAAAAAA;
    ledValue = 8'hAA;
    patternState = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkLEDBlinker

