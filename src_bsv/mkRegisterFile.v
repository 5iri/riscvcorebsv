//
// Generated by Bluespec Compiler, version 2025.01.1 (build 65e3a87)
//
// On Wed Apr 30 14:38:56 IST 2025
//
//
// Ports:
// Name                         I/O  size props
// RDY_write                      O     1 const
// read1                          O    32
// RDY_read1                      O     1 const
// read2                          O    32
// RDY_read2                      O     1 const
// CLK_clk                        I     1 unused
// RST_N_rst                      I     1 unused
// CLK                            I     1 clock
// RST_N                          I     1 unused
// write_wr_en                    I     1
// write_rd                       I     5
// write_data                     I    32
// read1_valid                    I     1
// read1_rs1                      I     5
// read2_valid                    I     1
// read2_rs2                      I     5
// EN_write                       I     1
//
// Combinational paths from inputs to outputs:
//   read1_valid -> read1
//   read2_valid -> read2
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkRegisterFile(CLK_clk,
		      RST_N_rst,
		      CLK,
		      RST_N,

		      write_wr_en,
		      write_rd,
		      write_data,
		      EN_write,
		      RDY_write,

		      read1_valid,
		      read1_rs1,
		      read1,
		      RDY_read1,

		      read2_valid,
		      read2_rs2,
		      read2,
		      RDY_read2);
  input  CLK_clk;
  input  RST_N_rst;
  input  CLK;
  input  RST_N;

  // action method write
  input  write_wr_en;
  input  [4 : 0] write_rd;
  input  [31 : 0] write_data;
  input  EN_write;
  output RDY_write;

  // value method read1
  input  read1_valid;
  input  [4 : 0] read1_rs1;
  output [31 : 0] read1;
  output RDY_read1;

  // value method read2
  input  read2_valid;
  input  [4 : 0] read2_rs2;
  output [31 : 0] read2;
  output RDY_read2;

  // signals for module outputs
  wire [31 : 0] read1, read2;
  wire RDY_read1, RDY_read2, RDY_write;

  // ports of submodule rf
  wire [31 : 0] rf$D_IN, rf$D_OUT_1, rf$D_OUT_2;
  wire [4 : 0] rf$ADDR_1,
	       rf$ADDR_2,
	       rf$ADDR_3,
	       rf$ADDR_4,
	       rf$ADDR_5,
	       rf$ADDR_IN;
  wire rf$WE;

  // action method write
  assign RDY_write = 1'd1 ;

  // value method read1
  assign read1 = read1_valid ? rf$D_OUT_2 : 32'd0 ;
  assign RDY_read1 = 1'd1 ;

  // value method read2
  assign read2 = read2_valid ? rf$D_OUT_1 : 32'd0 ;
  assign RDY_read2 = 1'd1 ;

  // submodule rf
  RegFile #(.addr_width(32'd5),
	    .data_width(32'd32),
	    .lo(5'd0),
	    .hi(5'd31)) rf(.CLK(CLK),
			   .ADDR_1(rf$ADDR_1),
			   .ADDR_2(rf$ADDR_2),
			   .ADDR_3(rf$ADDR_3),
			   .ADDR_4(rf$ADDR_4),
			   .ADDR_5(rf$ADDR_5),
			   .ADDR_IN(rf$ADDR_IN),
			   .D_IN(rf$D_IN),
			   .WE(rf$WE),
			   .D_OUT_1(rf$D_OUT_1),
			   .D_OUT_2(rf$D_OUT_2),
			   .D_OUT_3(),
			   .D_OUT_4(),
			   .D_OUT_5());

  // submodule rf
  assign rf$ADDR_1 = read2_rs2 ;
  assign rf$ADDR_2 = read1_rs1 ;
  assign rf$ADDR_3 = 5'h0 ;
  assign rf$ADDR_4 = 5'h0 ;
  assign rf$ADDR_5 = 5'h0 ;
  assign rf$ADDR_IN = (write_wr_en && write_rd != 5'd0) ? write_rd : 5'd0 ;
  assign rf$D_IN = (write_wr_en && write_rd != 5'd0) ? write_data : 32'd0 ;
  assign rf$WE = EN_write ;
endmodule  // mkRegisterFile

